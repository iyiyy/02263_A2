scheme NET =
class
  type 
   Net ::
     stops : Stop-set
     conns : Connection-set,
   
   Stop ::
     id : StopId
     cap : Capacity
     wt : WaitingTime,
   
   StopId = Text,  -- names of stops
   Capacity = Nat, -- capacities
   Time = Nat, -- times in number of minutes
   WaitingTime = Time, -- minimum waiting times 
   DrivingTime = Time, -- minimum driving times
   Track ::
    cap : Capacity
    dt : DrivingTime,
    
   Connection = StopId >< StopId >< Track

  value /* generators */
    empty :  Net = mk_Net({}, {}),  -- the empty net

    -- insert a stop with a given name, capacity and minimum waiting time
    insertStop : StopId >< Capacity >< WaitingTime >< Net -> Net
    insertStop(id, cap, wt, currNet) is (
      let
        newStop = mk_Stop(id, cap, wt)
      in
        mk_Net(stops(currNet) union {newStop}, conns(currNet))
      end
    ),
    
    -- add a connection between given stops, 
    -- with a given capacity and a given minimum driving time 
    addConnection : StopId >< StopId >< Capacity >< DrivingTime >< Net -> Net 
    addConnection(id1, id2, c, dt, currNet) is (
      let
        ss = stops(currNet),
        entry = (id1, id2, mk_Track(c, dt))
      in
        mk_Net(ss, conns(currNet) union {entry})
      end
    )
    
   
  value /* observers */

    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(sId, n) is (
      exists s : Stop :- s isin stops(n) /\ id(s) = sId
    ),
   
   getStop : StopId >< Net -> Stop
   getStop(sId, n) is (
     if isIn(sId, n) then
       hd {s | s : Stop :- s isin stops(n)}
     else
       mk_Stop("",0,0)
     end
   ),
   
    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(sId, n) is (
      cap(getStop(sId, n))
    ),

    -- get the minimum waiting time of a stop 
    minWaitingTime : StopId >< Net -~-> Time
	minWaitingTime(sId,n) is (
	  wt(getStop(sId, n))
	),
    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
	areDirectlyConnected(sId1, sId2, n) is (
	  let
	  	conn = conns(n),
	  	s = {sId1, sId2}
	  in
	  	card s < 3
	  end
	),
    -- get the capacity for a connection between two connected stops
    --capacity : StopId >< StopId >< Net -~-> Capacity,

    -- get minimum driving time between two connected stops        
    --minDrivingTime : StopId >< StopId >< Net -~-> Time
 
  --value /* predicates to check nets */
    isWellformed : Net -> Bool
    isWellformed(n) is (
      if n = empty then 
        false
      else
        all s : Stop :- s isin stops(n) => (
          all c : Connection :- c isin conns(n) => (
            isWellformed(s) /\ isWellformed(c)
          )
        )
      end
    ),
    
    isWellformed : Stop -> Bool
    isWellformed(s) is (
        id(s) ~= "" /\ cap(s) ~= 0 /\ wt(s) ~=0 
    ),
    
    isWellformed : Connection -> Bool
    isWellformed(c) is (
      let
        (sid1, sid2, t) = c
      in
       sid1 ~= "" /\ sid2 ~= "" /\ sid1 ~= sid2 /\
        cap(t) ~= 0 /\ dt(t) ~= 0
      end
    ),
    
    -- get all the stops in the net
    getStops : Net -> Stop-set
    getStops(n) is stops(n)
    
  test_case
    [t0] insertStop("s1", 1, 1, empty),
    [t1]
      let
        currNet = insertStop("s1", 1, 1, empty)
      in
        insertStop("s2", 1, 1, currNet)
      end,
    [t2]
      let
        net = insertStop("s1", 1, 1, insertStop("s2", 1, 1, empty))
      in
        addConnection("s1", "s2", 1, 12, net)
      end,
    [t3]
      let
        currNet = insertStop("s1", 1, 1, empty)
      in
        isIn("s1", currNet)
      end,
    [t4]
      let
        currNet = insertStop("s1", 55, 2221, empty)
      in
        capacity("s1", currNet)
      end,
    [t5]
      let
        currNet = insertStop("s1", 55, 2221, empty)
      in
        minWaitingTime("s1", currNet)
      end
end  