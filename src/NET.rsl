scheme NET =
class
  type 
    Net ::
      stops : Stop-set
      conns : Connection-set,
   
    Stop ::
      id : StopId
      cap : Capacity
      wt : WaitingTime,
   
    Track ::
      cap : Capacity
      dt : DrivingTime,

    Connection ::
    id1 : StopId
    id2 : StopId
      t : Track,

    StopId = Text,  -- names of stops
    Capacity = Nat, -- capacities
    Time = Nat, -- times in number of minutes
    WaitingTime = Time, -- minimum waiting times 
    DrivingTime = Time -- minimum driving times
    
      
  value /* generators */
    empty :  Net = mk_Net({}, {}),  -- the empty net
    emptyStop : Stop = mk_Stop("",0,0),
    emptyConn : Connection = mk_Connection("","",mk_Track(0,0)),
    
    -- insert a stop with a given name, capacity and minimum waiting time
    insertStop : StopId >< Capacity >< WaitingTime >< Net -> Net
    insertStop(id, cap, wt, currNet) is (
      let
        newStop = mk_Stop(id, cap, wt)
      in
        mk_Net(stops(currNet) union {newStop}, conns(currNet))
      end
    ),
    
    -- add a connection between given stops, 
    -- with a given capacity and a given minimum driving time 
    addConnection : StopId >< StopId >< Capacity >< DrivingTime >< Net -> Net 
    addConnection(id1, id2, c, dt, currNet) is (
      let
        ss = stops(currNet),
        entry = mk_Connection(id1, id2, mk_Track(c, dt))
      in
        mk_Net(ss, conns(currNet) union {entry})
      end
    )
    
  value /* observers */
    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(sid, n) is (
      if getStop(sid, n) ~= emptyStop then
        true
      else
        false
      end
    ),

    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(sId, n) is (
      cap(getStop(sId, n))
    ),

   
    -- get the minimum waiting time of a stop 
    minWaitingTime : StopId >< Net -~-> Time
    minWaitingTime(sId,n) is (
      wt(getStop(sId, n))
    ),

    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(id1, id2, n) is (
      let
        c = getConnection(id1, id2, n)
      in
        if c ~= emptyConn then
          true
        else
          false
        end
      end
    ),

    -- get the capacity for a connection between two connected stops
    capacity : StopId >< StopId >< Net -~-> Capacity
    capacity(id1, id2, n) is (
      if areDirectlyConnected(id1, id2, n) 
        then 
          cap(getStop(id1,n))
        else 
          0
      end
    ),

    -- get minimum driving time between two connected stops        
    minDrivingTime : StopId >< StopId >< Net -~-> Time
    minDrivingTime(id1, id2, n) is (
      dt(t(getConnection(id1, id2, n)))
    ), 
    
    getStop : StopId >< Net -> Stop
    getStop(sId, n) is (
      let
        s = {s | s : Stop :- s isin stops(n) /\ id(s) = sId}
      in
        if s = {} then
          hd s
        else
          emptyStop
        end
      end
    ),

    getConnection: StopId >< StopId >< Net -~-> Connection
    getConnection(id1, id2, n) is (
      let
        c ={c | c : Connection :- c isin conns(n) /\ matchingIds(id1, id2, c)}
      in
        if c = {} then
          emptyConn
        else
          hd c
        end
      end
    ),

    hasData : Stop -> Bool
    hasData(s) is (
      id(s) ~= "" /\ cap(s) ~= 0 /\ wt(s) ~=0 
    ),
   
    hasData : Connection -> Bool
    hasData(c) is (
      let
        t = t(c)
      in
        id1(c) ~= "" /\ id2(c) ~= "" /\ id1(c) ~= id2(c) /\
        cap(t) ~= 0 /\ dt(t) ~= 0
      end
    ),

    matchingIds : StopId >< StopId >< Connection -> Bool
    matchingIds(id1, id2, c) is (
      (id1(c) = id1 /\ id2(c) = id2) \/ 
      (id1(c) = id2 /\ id2(c) = id1)
    )

    
 
  value /* predicates to check nets */
    isWellformed : Net -> Bool
    isWellformed(n) is (
      if card stops(n) < 2 \/ card conns(n) < 1 then 
        false
      else
        allStopsAreConnected(stops(n), n) /\ noIsoNets(stops(n), n)
      end
    ),
    
    allStopsAreConnected : Stop-set >< Net -> Bool
    allStopsAreConnected(ss, n) is (
      all s1 : Stop :- s1 isin stops(n) => (
        exists s2 : Stop :- s2 isin stops(n) /\
          areDirectlyConnected(id(s1), id(s2), n)
      )
    ),
    
    noIsoNets : Stop-set >< Net -> Bool
    noIsoNets(ss, n) is (
      if card ss > 1 then
        exists s : Stop :- s isin ss /\ (
          exists otherS : Stop :- otherS isin ss /\ (
            areDirectlyConnected(id(s), id(otherS), n) /\ noIsoNets(ss \ {s}, n)
          )
        )
      else
        true
      end
    )
end  