scheme NET =
class
  type 
   Net ::
     stops : Stop-set
     conns : Connection-set,
   
   Stop ::
     id : StopId
     cap : Capacity
     wt : WaitingTime,
   
   StopId = Text,  -- names of stops
   Capacity = Nat, -- capacities
   Time = Nat, -- times in number of minutes
   WaitingTime = Time, -- minimum waiting times 
   DrivingTime = Time, -- minimum driving times
   Track ::
    cap : Capacity
    dt : DrivingTime,
    
   --Connection = StopId >< StopId >< Track
    Connection ::
      id1 : StopId
      id2 : StopId
      t : Track
      
  value /* generators */
    empty :  Net = mk_Net({}, {}),  -- the empty net
    emptyStop : Stop = mk_Stop("",0,0),
    emptyConn : Connection = mk_Connection("","",mk_Track(0,0)),
    
    -- insert a stop with a given name, capacity and minimum waiting time
    insertStop : StopId >< Capacity >< WaitingTime >< Net -> Net
    insertStop(id, cap, wt, currNet) is (
      let
        newStop = mk_Stop(id, cap, wt)
      in
        mk_Net(stops(currNet) union {newStop}, conns(currNet))
      end
    ),
    
    -- add a connection between given stops, 
    -- with a given capacity and a given minimum driving time 
    addConnection : StopId >< StopId >< Capacity >< DrivingTime >< Net -> Net 
    addConnection(id1, id2, c, dt, currNet) is (
      let
        ss = stops(currNet),
        entry = mk_Connection(id1, id2, mk_Track(c, dt))
      in
        mk_Net(ss, conns(currNet) union {entry})
      end
    )
    
   
  value /* observers */
    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(sid, n) is (
      if getStop(sid, n) ~= emptyStop then
        true
      else
        false
      end
    ),
   
   getStop : StopId >< Net -> Stop
   getStop(sId, n) is (
     let
       s = {s | s : Stop :- s isin stops(n) /\ id(s) = sId}
     in
       if s = {} then
         hd s
       else
         emptyStop
       end
     end
   ),
   
   hasData : Stop -> Bool
   hasData(s) is (
     id(s) ~= "" /\ cap(s) ~= 0 /\ wt(s) ~=0 
   ),
   
    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(sId, n) is (
      cap(getStop(sId, n))
    ),

    -- get the minimum waiting time of a stop 
    minWaitingTime : StopId >< Net -~-> Time
	minWaitingTime(sId,n) is (
	  wt(getStop(sId, n))
	),
    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(id1, id2, n) is (
      let
        c = getConnection(id1, id2, n)
      in
        if c ~= emptyConn then
          true
        else
          false
        end
      end
	),
	
   getConnection: StopId >< StopId >< Net -~-> Connection
   getConnection(id1, id2, n) is (
     let
       c ={c | c : Connection :- c isin conns(n) /\ matchingIds(id1, id2, c)}
     in
       if c = {} then
         emptyConn
       else
         hd c
       end
     end
   ),
	
    matchingIds : StopId >< StopId >< Connection -> Bool
    matchingIds(id1, id2, c) is (
      (id1(c) = id1 /\ id2(c) = id2) \/ 
      (id1(c) = id2 /\ id2(c) = id1)
    ),
    -- get the capacity for a connection between two connected stops
    capacity : StopId >< StopId >< Net -~-> Capacity
    capacity(id1, id2, n) is (
      if areDirectlyConnected(id1, id2, n) 
      	then 
      		cap(getStop(id1,n))
      	else 
      		0
      end
    ),
    -- get minimum driving time between two connected stops        
    minDrivingTime : StopId >< StopId >< Net -~-> Time
    minDrivingTime(id1, id2, n) is (
      dt(t(getConnection(id1, id2, n)))
    ) 
    
 
  value /* predicates to check nets */
    isWellformed : Net -> Bool
    isWellformed(n) is (
      if n = empty then 
        false
      else
        allStopsAreConnected(stops(n), n)
      end
    ),
    
    allStopsAreConnected : Stop-set >< Net -> Bool
    allStopsAreConnected(ss, n) is (
      all s1 : Stop :- s1 isin stops(n) => (
        exists s2 : Stop :- s2 isin stops(n) /\
          areDirectlyConnected(id(s1), id(s2), n)
      )
    ),
    
    allConnectionsAreValid : Connection-set >< Net -> Bool
    allConnectionsAreValid(cs, n) is (
      all c : Connection :- c isin cs => (
        exists s1 : Stop :- s1 isin stops(n) /\ (
          exists s2 : Stop :- s2 isin stops(n) /\
          id1(c) = id(s1) /\ id2(c) = id(s2)
        ) 
      )
    ),
    
    isWellformed : Stop -> Bool
    isWellformed(s) is (
        id(s) ~= "" /\ cap(s) ~= 0 /\ wt(s) ~=0 
    ),
    
    isWellformed : Connection -> Bool
    isWellformed(c) is (
      let
        t = t(c)
      in
       id1(c) ~= "" /\ id2(c) ~= "" /\ id1(c) ~= id2(c) /\
        cap(t) ~= 0 /\ dt(t) ~= 0
      end
    ),
    
    -- get all the stops in the net
    getStops : Net -> Stop-set
    getStops(n) is stops(n)
    
  test_case
    [t0] insertStop("s1", 1, 1, empty),
    [t1]
      let
        currNet = insertStop("s1", 1, 1, empty)
      in
        insertStop("s2", 1, 1, currNet)
      end,
    [t2]
      let
        net = insertStop("s1", 1, 1, insertStop("s2", 1, 1, empty))
      in
        addConnection("s1", "s2", 1, 12, net)
      end,
    [t3]
      let
        currNet = insertStop("s1", 1, 1, empty)
      in
        isIn("s1", currNet)
      end,
    [t4]
      let
        currNet = insertStop("s1", 55, 2221, empty)
      in
        capacity("s1", currNet)
      end,
    [t5]
      let
        currNet = insertStop("s1", 55, 2221, empty)
      in
        minWaitingTime("s1", currNet)
      end
end  