	NET
scheme TIMETABLE = extend NET with
class
  type 
    TimeTable = TramId -m-> Plan, -- time tables as a map
    TramId = Text, -- tram names
	Trip ::
	  id : StopId
	  arrt : Time
	  dept : Time, -- a trip in a time table
	Plan = Trip-list -- a list of trips 
    value /* generators */
      -- the empty timetable
      empty: TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram: TramId >< TimeTable -> TimeTable
      addTram(tid, tt) is (
        tt !! [tid +> <..>]
      ),

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tid, sid, arrt, dept, tt) is (
        tt !! [tid +> getPlan(tid, tt) ^ <.mk_Trip(sid, arrt, dept).>]
      ),
      
      getPlan : TramId >< TimeTable -~-> Plan
      getPlan(tid, tt) is (
        hd rng (tt / {tid})
      )
      -- get
  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tid, tt) is (
       tid isin tt
     )
     -- you can add more observers here
     --...
 
  value /* predicates to check time tables */   
     isWellformed : TimeTable >< Net -> Bool
     isWellformed(t, n) is (
        true
     ),
     
     
is_sorted : Int-list -> Bool
is_sorted(l) is (
  all idx1 : Nat :- idx1 isin inds l => (
    exists idx2 : Nat :- idx2 isin inds l /\
      idx2 - idx1 <= 1 /\ l(idx1) <= l(idx2))
    ),
     
     wffPlan : Plan >< Net -> Nat
     wffPlan(p, n) is (
       local
         value
         l : Nat = len p,
         i : Nat = 1,
         j : Nat = 2,
         s1 : Stop = getStop(id(p(i)), n),
         s2 : Stop = getStop(id(p(j)), n),
         c : Connection = getConnection(id(s1), id(s2), n)
       in
         do
           j = j + 1
         until
           j - (len p) = 1
         end;
         j
       end
     )

     --...
  test_case
    [t0] addTram("t1", empty),
    [t1] 
      let 
        m = ["t1" +> <..>, "t2" +> <.mk_Trip("s1", 0, 2).>]
      in
        addStop("t1", "s2", 0, 2, m)
      end,
    [t2]
      let
        s1 = mk_Stop("s1", 2, 2),
        s2 = mk_Stop("s2", 1, 1),
        s3 = mk_Stop("s3", 1, 1),
        c12 = mk_Connection("s1", "s2", mk_Track(1,1)),
        c13 = mk_Connection("s1", "s3", mk_Track(1,1)),
        n = mk_Net({s1,s2,s3}, {c12,c13}),
        tr1 = mk_Trip("s1", 0, 2),
        tr2 = mk_Trip("s2", 3, 4),
        tr3 = mk_Trip("s1", 5, 7),
        p = <.tr1, tr2, tr3.>
      in
        isWellformed(n)
      end,
     [t3] is_sorted(<.1,2,3.>)
end  
